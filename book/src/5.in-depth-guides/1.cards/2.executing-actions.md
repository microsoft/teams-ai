# Executing Actions

Adaptive Cards support interactive elements through **actions**—buttons, links, and input submission triggers that respond to user interaction.  
You can use these to collect form input, trigger workflows, show task modules, open URLs, and more.

---

## 1 Action Types

The Teams SDK supports several action types for different interaction patterns:

| Action Type               | Purpose                | Description                                                                  |
| ------------------------- | ---------------------- | ---------------------------------------------------------------------------- |
| `Action.Execute`          | Server‑side processing | Send data to your bot for processing. Best for forms & multi‑step workflows. |
| `Action.Submit`           | Simple data submission | Legacy action type. Prefer `Execute` for new projects.                       |
| `Action.OpenUrl`          | External navigation    | Open a URL in the user's browser.                                            |
| `Action.ShowCard`         | Progressive disclosure | Display a nested card when clicked.                                          |
| `Action.ToggleVisibility` | UI state management    | Show/hide card elements dynamically.                                         |

> For complete reference, see the [official documentation](https://adaptivecards.microsoft.com/?topic=Action.Execute).

---

## 2 Creating Actions with the SDK

### Single Actions

The SDK provides builder helpers that abstract the underlying JSON. For example:

```ts
import { ExecuteAction } from "@microsoft/teams.cards";

const action = new ExecuteAction({ title: "Submit" }).withData({
  action: "save_profile",
  userId: "123",
});
```

### Action Sets

Group actions together using `ActionSet`:

```ts
import {
  Card,
  ExecuteAction,
  OpenUrlAction,
  ActionSet,
} from "@microsoft/teams.cards";

const card = new Card().withBody(
  /* other elements... */
  new ActionSet(
    new ExecuteAction({ title: "Save" }).withData({ action: "save_profile" }),
    new OpenUrlAction({
      title: "Learn more",
      url: "https://example.com",
    })
  )
);
```

### Raw JSON Alternative

For action types without dedicated helpers, use raw JSON adhering to the `IAction` interface:

```ts
const customAction = {
  type: "Action.Execute",
  title: "Submit",
  data: {
    action: "save_profile",
    userId: "123",
  },
  associatedInputs: "auto",
} as const;
```

---

## 3 Working with Input Values

### Automatic Input Collection

Use `associatedInputs: "auto"` to automatically capture all input values when an action executes:

```ts
const card = new Card().withBody(
  new TextInput({ id: "name" }).withLabel("Name"),
  new TextInput({ id: "email" }).withLabel("Email"),
  new ToggleInput({ id: "subscribe" }).withLabel("Subscribe to newsletter"),
  new ActionSet(
    new ExecuteAction({ title: "Save" })
      .withData({ action: "save_profile" })
      .withAssociatedInputs("auto") // All input values included
  )
);
```

The values appear in your handler as `data.<input_id>`. For example, when the user fills out the form above:

```ts
// Data received in handler
{
  action: "save_profile",
  name: "John Doe",      // From name input
  email: "john@doe.com", // From email input
  subscribe: "true"      // From toggle input (as string)
}
```

### Manual Collection

Set `associatedInputs: "none"` to control which inputs get included. For example, if you only want to capture a specific input:

```ts
const card = new Card().withBody(
  new TextInput({ id: "name" }).withLabel("Name"),
  new TextInput({ id: "age" }).withLabel("Age"),
  new TextInput({ id: "location" }).withLabel("Location"),
  new ActionSet(
    new ExecuteAction({ title: "Save" })
      .withData({
        action: "save_profile",
        name: "${name}", // Reference specific input
      })
      .withAssociatedInputs("none") // Don't include other inputs
  )
);
```

When this action executes, only the "name" input value will be included in the data, while "age" and "location" are omitted.

---

## 4 Server‑side Handlers

### Basic Structure

Card actions arrive as `card.action` activities in your app. Handle them like this:

```ts
app.on("card.action", async ({ activity, send, api }) => {
  // Verify action data exists
  const data = activity.value?.action?.data;
  if (!data?.action) {
    return {
      statusCode: 400,
      type: "application/vnd.microsoft.activity.message",
      value: "No action specified",
    };
  }

  // Route based on the verb
  switch (data.action) {
    case "save_profile":
      return handleProfileSave(data, service);
    default:
      return {
        statusCode: 400,
        type: "application/vnd.microsoft.activity.message",
        value: "Unknown action",
      };
  }

  // Return result to Teams
  return {
    statusCode: 200,
    type: "application/vnd.microsoft.activity.message",
    value: response?.value || "",
  };
});
```

This pattern gives you:

- Access to app services and APIs via the handler parameters
- Clean separation between action routing and business logic
- Proper error handling for service initialization
- Consistent response format back to Teams

### Input Handling

Be defensive when working with inputs—values arrive as strings and need validation:

```ts
function handleProfileSave(data: Record<string, unknown>) {
  // Validate required fields
  if (typeof data.name !== "string") {
    throw new Error("Name is required");
  }

  // Parse numbers, dates etc.
  const age = data.age ? parseInt(data.age as string, 10) : undefined;

  // Continue processing...
}
```

### Real‑world Example

Here's a trimmed version of the stand‑up bot's card handler:

```ts
export async function handleCardAction(activity: any, send: Function) {
  const data = activity.value?.action?.data;
  const conversationId = activity.conversation.id;

  switch (data?.action) {
    case "submit_standup": {
      // Extract input values
      const response = {
        userId: data.userId,
        completedWork: data.completedWork,
        plannedWork: data.plannedWork,
        timestamp: new Date(),
      };

      // Process the standup entry
      const result = await submitStandupEntry(conversationId, response);

      // Send result back to Teams
      return {
        statusCode: 200,
        type: "application/vnd.microsoft.activity.message",
        value: result.message,
      };
    }

    case "close_standup": {
      // Get unchecked items
      const uncheckedItems = Object.entries(data)
        .filter(
          ([key, value]) =>
            key.startsWith("parking_lot_") &&
            String(value).startsWith("Not Discussed - ")
        )
        .map(([_, value]) => String(value).replace("Not Discussed - ", ""));

      // Process them
      await handleUncheckedItems(uncheckedItems);

      // Close the standup
      return await closeStandup(conversationId);
    }

    default:
      return {
        statusCode: 400,
        type: "application/vnd.microsoft.activity.message",
        value: "Unknown action",
      };
  }
}
```

---

## 5 End‑to‑end Example

A minimal card with an input and action handler:

```ts
// Define the greeting card
function createGreetingCard() {
  return new Card().withBody(
    new TextInput({ id: "name_input" }).withLabel("Your name"),
    new ActionSet(
      new ExecuteAction({ title: "Say hello" })
        .withData({ action: "greet" })
        .withAssociatedInputs("auto")
    )
  );
}

// Send the card when a message is received
app.on("message", async ({ send }) => {
  await send({ type: "typing" });
  await send(createGreetingCard());
});

// Handle card actions
app.on("card.action", async ({ activity, send }) => {
  const data = activity.value?.action?.data;

  if (data?.action === "greet") {
    // Get name from input
    const name = data.name_input;

    // Send response
    await send(`Hello, ${name}!`);

    // Return success
    return {
      statusCode: 200,
      type: "application/vnd.microsoft.activity.message",
      value: "Greeting sent",
    };
  }

  return {
    statusCode: 400,
    type: "application/vnd.microsoft.activity.message",
    value: "Unknown action",
  };
});
```

---

### Summary

- Use **`Action.Execute`** for modern Teams integration.
- Let the SDK's **builder helpers** handle action JSON.
- Choose between **auto/manual** input collection.
- Structure handlers around the **verb pattern**.
- Always **validate** incoming data.
