## API Report File for "@microsoft/teams-ai"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from 'botbuilder';
import { BotAdapter } from 'botbuilder';
import { ConversationReference } from 'botbuilder';
import { MessagingExtensionResult } from 'botbuilder';
import { ResourceResponse } from 'botbuilder';
import { Storage as Storage_2 } from 'botbuilder';
import { TaskModuleTaskInfo } from 'botbuilder';
import { TurnContext } from 'botbuilder';
import { TurnContext as TurnContext_2 } from 'botbuilder-core';

// @public
export interface AdaptiveCard {
    [key: string]: any;
    type: 'AdaptiveCard';
}

// @public
export class AdaptiveCards<TState extends TurnState> {
    constructor(app: Application<TState>);
    actionExecute<TData = Record<string, any>>(verb: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<AdaptiveCard | string>): Application<TState>;
    actionSubmit<TData = Record<string, any>>(verb: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<void>): Application<TState>;
    // (undocumented)
    search(dataset: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, query: Query<AdaptiveCardsSearchParams>) => Promise<AdaptiveCardSearchResult[]>): Application<TState>;
}

// @public
export interface AdaptiveCardSearchResult {
    title: string;
    value: string;
}

// @public
export interface AdaptiveCardsOptions {
    actionSubmitFilter?: string;
}

// @public
export interface AdaptiveCardsSearchParams {
    dataset: string;
    queryText: string;
}

// @public
export class AI<TState extends TurnState = DefaultTurnState> {
    constructor(options: AIOptions<TState>);
    action<TEntities extends Record<string, any> | undefined>(name: string | string[], handler: (context: TurnContext, state: TState, entities: TEntities, action?: string) => Promise<boolean>, allowOverrides?: boolean): this;
    chain(context: TurnContext, state: TState, prompt?: string | PromptTemplate, options?: Partial<AIOptions<TState>>): Promise<boolean>;
    completePrompt(context: TurnContext, state: TState, prompt: string | PromptTemplate, options?: Partial<AIOptions<TState>>): Promise<string | undefined>;
    createSemanticFunction(name: string, template?: PromptTemplate, options?: Partial<AIOptions<TState>>): (context: TurnContext, state: TState) => Promise<any>;
    doAction<TEntities = Record<string, any>>(context: TurnContext, state: TState, action: string, entities?: TEntities): Promise<boolean>;
    static readonly DoCommandActionName = "___DO___";
    static readonly FlaggedInputActionName = "___FlaggedInput___";
    static readonly FlaggedOutputActionName = "___FlaggedOutput___";
    get moderator(): Moderator<TState>;
    get options(): ConfiguredAIOptions<TState>;
    get planner(): Planner<TState>;
    static readonly PlanReadyActionName = "___PlanReady___";
    get prompts(): PromptManager<TState>;
    static readonly RateLimitedActionName = "___RateLimited___";
    static readonly SayCommandActionName = "___SAY___";
    static readonly UnknownActionName = "___UnknownAction___";
}

// @public
export interface AIHistoryOptions {
    assistantHistoryType: 'text' | 'planObject';
    assistantPrefix: string;
    lineSeparator: string;
    maxTokens: number;
    maxTurns: number;
    trackHistory: boolean;
    userPrefix: string;
}

// @public
export interface AIOptions<TState extends TurnState> {
    history?: Partial<AIHistoryOptions>;
    moderator?: Moderator<TState>;
    planner: Planner<TState>;
    prompt?: string | PromptTemplate | PromptSelector<TState>;
    promptManager: PromptManager<TState>;
}

// @public
export class Application<TState extends TurnState = DefaultTurnState> {
    constructor(options?: ApplicationOptions<TState>);
    activity(type: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<void>): this;
    get adaptiveCards(): AdaptiveCards<TState>;
    addRoute(selector: RouteSelector, handler: RouteHandler<TState>, isInvokeRoute?: boolean): this;
    get ai(): AI<TState>;
    continueConversationAsync(context: TurnContext, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    // (undocumented)
    continueConversationAsync(conversationReference: Partial<ConversationReference>, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    // (undocumented)
    continueConversationAsync(activity: Partial<Activity>, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    conversationUpdate(event: ConversationUpdateEvents | ConversationUpdateEvents[], handler: (context: TurnContext, state: TState) => Promise<void>): this;
    message(keyword: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<void>): this;
    get messageExtensions(): MessageExtensions<TState>;
    messageReactions(event: MessageReactionEvents | MessageReactionEvents[], handler: (context: TurnContext, state: TState) => Promise<void>): this;
    get options(): ApplicationOptions<TState>;
    run(turnContext: TurnContext): Promise<boolean>;
    sendProactiveActivity(context: TurnContext, activityOrText: string | Partial<Activity>, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    // (undocumented)
    sendProactiveActivity(conversationReference: Partial<ConversationReference>, activityOrText: string | Partial<Activity>, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    // (undocumented)
    sendProactiveActivity(activity: Partial<Activity>, activityOrText: string | Partial<Activity>, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    startTypingTimer(context: TurnContext): void;
    stopTypingTimer(): void;
    get taskModules(): TaskModules<TState>;
    turn(event: TurnEvents | TurnEvents[], handler: (context: TurnContext, state: TState) => Promise<boolean>): this;
}

// @public
export interface ApplicationOptions<TState extends TurnState> {
    adapter?: BotAdapter;
    adaptiveCards?: AdaptiveCardsOptions;
    ai?: AIOptions<TState>;
    botAppId?: string;
    longRunningMessages?: boolean;
    removeRecipientMention?: boolean;
    startTypingTimer?: boolean;
    storage?: Storage_2;
    taskModules?: TaskModulesOptions;
    turnStateManager?: TurnStateManager<TState>;
}

// @public
export class AzureOpenAIModerator<TState extends TurnState = DefaultTurnState> extends OpenAIModerator<TState> {
    constructor(options: AzureOpenAIModeratorOptions);
    // Warning: (ae-forgotten-export) The symbol "AzureOpenAIClient" needs to be exported by the entry point index.d.ts
    protected createClient(options: OpenAIModeratorOptions): AzureOpenAIClient;
    // Warning: (ae-forgotten-export) The symbol "CreateModerationResponseResultsInner" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected createModeration(input: string): Promise<CreateModerationResponseResultsInner | undefined>;
    reviewPlan(context: TurnContext, state: TState, plan: Plan): Promise<Plan>;
    reviewPrompt(context: TurnContext, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<Plan | undefined>;
}

// @public
export interface AzureOpenAIModeratorOptions extends OpenAIModeratorOptions {
    // Warning: (ae-forgotten-export) The symbol "AzureOpenAIModeratorCategory" needs to be exported by the entry point index.d.ts
    categories?: AzureOpenAIModeratorCategory[];
}

// @public
export class AzureOpenAIPlanner<TState extends TurnState = DefaultTurnState> extends OpenAIPlanner<TState, AzureOpenAIPlannerOptions> {
    // Warning: (ae-forgotten-export) The symbol "OpenAIClient" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    protected createClient(options: AzureOpenAIPlannerOptions): OpenAIClient;
}

// @public
export interface AzureOpenAIPlannerOptions extends OpenAIPlannerOptions {
    apiVersion?: string;
    endpoint: string;
}

// @public
export interface CompletionConfig {
    frequency_penalty: number;
    max_tokens: number;
    presence_penalty: number;
    stop_sequences?: string[];
    temperature: number;
    top_p: number;
}

// @public
export interface ConfiguredAIOptions<TState extends TurnState> {
    history: AIHistoryOptions;
    moderator: Moderator<TState>;
    planner: Planner<TState>;
    prompt?: string | PromptTemplate | ((Context: TurnContext, state: TState) => Promise<string | PromptTemplate>);
    promptManager: PromptManager<TState>;
}

// @public
export class ConversationHistory {
    static addLine(state: TurnState, line: string, maxLines?: number): void;
    static appendToLastLine(state: TurnState, text: string): void;
    static clear(state: TurnState): void;
    static getLastLine(state: TurnState): string;
    static getLastSay(state: TurnState): string;
    static hasMoreLines(state: TurnState): boolean;
    static removeLastLine(state: TurnState): string | undefined;
    static replaceLastLine(state: TurnState, line: string): void;
    static replaceLastSay(state: TurnState, newResponse: string, assistantPrefix?: string): void;
    static readonly StatePropertyName = "__history__";
    static toArray(state: TurnState, maxTokens?: number): string[];
    static toString(state: TurnState, maxTokens?: number, lineSeparator?: string): string;
}

// @public
export type ConversationUpdateEvents = 'channelCreated' | 'channelRenamed' | 'channelDeleted' | 'channelRestored' | 'membersAdded' | 'membersRemoved' | 'teamRenamed' | 'teamDeleted' | 'teamArchived' | 'teamUnarchived' | 'teamRestored';

// @public
export interface DefaultConversationState {
}

// @public
export class DefaultModerator<TState extends TurnState = DefaultTurnState> implements Moderator<TState> {
    reviewPlan(context: TurnContext_2, state: TState, plan: Plan): Promise<Plan>;
    reviewPrompt(context: TurnContext_2, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<Plan | undefined>;
}

// @public
export class DefaultPromptManager<TState extends TurnState = DefaultTurnState> implements PromptManager<TState> {
    constructor(options: DefaultPromptManagerOptions | string);
    addFunction(name: string, handler: (context: TurnContext, state: TState) => Promise<any>, allowOverrides?: boolean): this;
    addPromptTemplate(name: string, template: PromptTemplate): this;
    invokeFunction(context: TurnContext, state: TState, name: string): Promise<any>;
    loadPromptTemplate(name: string): Promise<PromptTemplate>;
    renderPrompt(context: TurnContext, state: TState, nameOrTemplate: string | PromptTemplate): Promise<PromptTemplate>;
}

// @public
export interface DefaultPromptManagerOptions {
    promptsFolder: string;
}

// @public
export interface DefaultTempState {
    history: string;
    input: string;
    output: string;
}

// @public
export interface DefaultTurnState<TConversationState extends DefaultConversationState = DefaultConversationState, TUserState extends DefaultUserState = DefaultUserState, TTempState extends DefaultTempState = DefaultTempState> extends TurnState {
    // (undocumented)
    conversation: TurnStateEntry<TConversationState>;
    // (undocumented)
    temp: TurnStateEntry<TTempState>;
    // (undocumented)
    user: TurnStateEntry<TUserState>;
}

// @public
export class DefaultTurnStateManager<TConversationState extends DefaultConversationState = DefaultConversationState, TUserState extends DefaultUserState = DefaultUserState, TTempState extends DefaultTempState = DefaultTempState> implements TurnStateManager<DefaultTurnState<TConversationState, TUserState, TTempState>> {
    loadState(storage: Storage_2, context: TurnContext): Promise<DefaultTurnState<TConversationState, TUserState, TTempState>>;
    saveState(storage: Storage_2, context: TurnContext, state: DefaultTurnState<TConversationState, TUserState, TTempState>): Promise<void>;
}

// @public
export interface DefaultUserState {
}

// @public
export class MessageExtensions<TState extends TurnState> {
    constructor(app: Application<TState>);
    anonymousQueryLink(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, url: string) => Promise<MessagingExtensionResult>): Application<TState>;
    botMessagePreviewEdit(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, previewActivity: Partial<Activity>) => Promise<MessagingExtensionResult | TaskModuleTaskInfo | string | null | undefined>): Application<TState>;
    botMessagePreviewSend(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, previewActivity: Partial<Activity>) => Promise<void>): Application<TState>;
    fetchTask(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState) => Promise<TaskModuleTaskInfo | string>): Application<TState>;
    query<TParams extends Record<string, any> = Record<string, any>>(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, query: Query<TParams>) => Promise<MessagingExtensionResult>): Application<TState>;
    queryLink(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, url: string) => Promise<MessagingExtensionResult>): Application<TState>;
    selectItem<TItem extends Record<string, any> = Record<string, any>>(handler: (context: TurnContext, state: TState, item: TItem) => Promise<MessagingExtensionResult>): Application<TState>;
    submitAction<TData extends Record<string, any>>(commandId: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<MessagingExtensionResult | TaskModuleTaskInfo | string | null | undefined>): Application<TState>;
}

// @public
export type MessageReactionEvents = 'reactionsAdded' | 'reactionsRemoved';

// @public
export interface Moderator<TState extends TurnState> {
    reviewPlan(context: TurnContext_2, state: TState, plan: Plan): Promise<Plan>;
    reviewPrompt(context: TurnContext_2, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<Plan | undefined>;
}

// @public
export class OpenAIModerator<TState extends TurnState = DefaultTurnState> implements Moderator<TState> {
    constructor(options: OpenAIModeratorOptions);
    // (undocumented)
    protected createClient(options: OpenAIModeratorOptions): OpenAIClient;
    // (undocumented)
    protected createModeration(input: string, model?: string): Promise<CreateModerationResponseResultsInner | undefined>;
    // (undocumented)
    get options(): OpenAIModeratorOptions;
    reviewPlan(context: TurnContext, state: TState, plan: Plan): Promise<Plan>;
    reviewPrompt(context: TurnContext, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<Plan | undefined>;
}

// @public
export interface OpenAIModeratorOptions {
    apiKey: string;
    apiVersion?: string;
    endpoint?: string;
    model?: string;
    moderate: 'input' | 'output' | 'both';
    organization?: string;
}

// @public
export class OpenAIPlanner<TState extends TurnState = DefaultTurnState, TOptions extends OpenAIPlannerOptions = OpenAIPlannerOptions> implements Planner<TState> {
    constructor(options: TOptions);
    completePrompt(context: TurnContext, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<string>;
    // (undocumented)
    protected createClient(options: TOptions): OpenAIClient;
    generatePlan(context: TurnContext, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<Plan>;
    get options(): TOptions;
}

// @public
export interface OpenAIPlannerOptions {
    apiKey: string;
    defaultModel: string;
    endpoint?: string;
    logRequests?: boolean;
    oneSayPerTurn?: boolean;
    organization?: string;
    useSystemMessage?: boolean;
}

// @public (undocumented)
export interface ParsedCommandResult {
    // (undocumented)
    command?: PredictedCommand;
    // (undocumented)
    length: number;
}

// @public
export interface Plan {
    commands: PredictedCommand[];
    type: 'plan';
}

// @public
export interface Planner<TState extends TurnState> {
    completePrompt(context: TurnContext, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<string | undefined>;
    generatePlan(context: TurnContext, state: TState, prompt: PromptTemplate, options: ConfiguredAIOptions<TState>): Promise<Plan>;
}

// @public
export interface PredictedCommand {
    type: 'DO' | 'SAY';
}

// @public
export interface PredictedDoCommand extends PredictedCommand {
    action: string;
    entities: Record<string, any>;
    type: 'DO';
}

// @public
export interface PredictedDoCommandAndHandler<TState> extends PredictedDoCommand {
    handler: (context: TurnContext, state: TState, entities?: Record<string, any>, action?: string) => Promise<boolean>;
}

// @public
export interface PredictedSayCommand extends PredictedCommand {
    response: string;
    type: 'SAY';
}

// @public
export interface PromptManager<TState extends TurnState> {
    addFunction(name: string, handler: (context: TurnContext, state: TState) => Promise<any>, allowOverrides?: boolean): this;
    addPromptTemplate(name: string, template: PromptTemplate): this;
    invokeFunction(context: TurnContext, state: TState, name: string): Promise<any>;
    renderPrompt(context: TurnContext, state: TState, nameOrTemplate: string | PromptTemplate): Promise<PromptTemplate>;
}

// @public
export type PromptSelector<TState extends TurnState> = (context: TurnContext, state: TState) => Promise<string | PromptTemplate>;

// @public
export interface PromptTemplate {
    config: PromptTemplateConfig;
    text: string;
}

// @public
export interface PromptTemplateConfig {
    completion: CompletionConfig;
    default_backends?: string[];
    description: string;
    schema: number;
    type: 'completion';
}

// @public
export interface Query<TParams extends Record<string, any>> {
    count: number;
    parameters: TParams;
    skip: number;
}

// @public
export class ResponseParser {
    static parseAdaptiveCard(text?: string): Record<string, any> | undefined;
    // (undocumented)
    static parseDoCommand(tokens: string[]): ParsedCommandResult;
    static parseJSON<T = Record<string, any>>(text?: string): T | undefined;
    static parseResponse(text?: string): Plan;
    // (undocumented)
    static parseSayCommand(tokens: string[]): ParsedCommandResult;
    // (undocumented)
    static tokenizeText(text?: string): string[];
}

// @public
export type RouteHandler<TState extends TurnState> = (context: TurnContext, state: TState) => Promise<void>;

// @public
export type RouteSelector = (context: TurnContext) => Promise<boolean>;

// @public
export class TaskModules<TState extends TurnState> {
    constructor(app: Application<TState>);
    fetch<TData extends Record<string, any> = Record<string, any>>(verb: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<TaskModuleTaskInfo | string>): Application<TState>;
    submit<TData extends Record<string, any> = Record<string, any>>(verb: string | RegExp | RouteSelector | (string | RegExp | RouteSelector)[], handler: (context: TurnContext, state: TState, data: TData) => Promise<TaskModuleTaskInfo | string | null | undefined>): Application<TState>;
}

// @public
export interface TaskModulesOptions {
    taskDataFilter?: string;
}

// @public
export type TurnEvents = 'beforeTurn' | 'afterTurn';

// @public
export interface TurnState {
    [key: string]: TurnStateEntry;
}

// @public
export class TurnStateEntry<TValue extends Record<string, any> = Record<string, any>> {
    constructor(value?: TValue, storageKey?: string);
    delete(): void;
    get hasChanged(): boolean;
    get isDeleted(): boolean;
    replace(value?: TValue): void;
    get storageKey(): string | undefined;
    get value(): TValue;
}

// @public
export interface TurnStateManager<TState extends TurnState> {
    loadState(storage: Storage_2 | undefined, context: TurnContext): Promise<TState>;
    saveState(storage: Storage_2 | undefined, context: TurnContext, state: TState): Promise<void>;
}

// (No @packageDocumentation comment for this package)

```
